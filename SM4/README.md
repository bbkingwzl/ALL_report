# SM4
本次实验实现了SM4的ECB模式以及CBC模式，本次实验为笔者独自完成。引用部分在文中有所展示。
## 运行解释以及注意事项
在下载完毕所提供的文件后，直接运行testLC即可。
## ECB模式算法实现
对于普遍的遍历实现方式，无论是在密钥扩展算法中或是加密算法中，对于三十二轮中的每一轮来说都会存在一个 32 长的中间数组存储 K 或 X，而这将会增大空间开销，并且访问数组的速度慢于访问普通变量的速度，因此在具体的实现过程中将对此方面进行优化。   
具体的优化实现方式为，区别于传统方式，对于密钥扩展算法以及加密算法的中间变量仅开辟四个内存空间使用强制类型转换即以四个变量进行承接。对于 32 轮的 for 循环，将其改变为仅进行 8 次 for 循环而对于每次内层循环而言，每次进行四次运算，每次将中间变量的值与 rk 或 x 进行替换，以此节省空间开销以及时间开销。核心代码实现如下：
```c
int SM4Crypt(const muint8* Input, muint8* Output, const muint32* rk)
{
	muint32 r, mid, x0, x1, x2, x3, * p;
	p = (muint32*)Input;
	x0 = p[0];
	x1 = p[1];
	x2 = p[2];
	x3 = p[3];
#ifdef LITTLE_ENDIAN
	x0 = Rotl(x0, 16); x0 = ((x0 & 0x00FF00FF) << 8) ^ ((x0 & 0xFF00FF00) >> 8);
	x1 = Rotl(x1, 16); x1 = ((x1 & 0x00FF00FF) << 8) ^ ((x1 & 0xFF00FF00) >> 8);
	x2 = Rotl(x2, 16); x2 = ((x2 & 0x00FF00FF) << 8) ^ ((x2 & 0xFF00FF00) >> 8);
	x3 = Rotl(x3, 16); x3 = ((x3 & 0x00FF00FF) << 8) ^ ((x3 & 0xFF00FF00) >> 8);
#endif
	for (r = 0; r < 32; r += 4)
	{
		mid = x1 ^ x2 ^ x3 ^ rk[r + 0];
		mid = ByteSub(mid);
		x0 ^= L1(mid);
		mid = x2 ^ x3 ^ x0 ^ rk[r + 1];
		mid = ByteSub(mid);
		x1 ^= L1(mid);
		mid = x3 ^ x0 ^ x1 ^ rk[r + 2];
		mid = ByteSub(mid);
		x2 ^= L1(mid);
		mid = x0 ^ x1 ^ x2 ^ rk[r + 3];
		mid = ByteSub(mid);
		x3 ^= L1(mid);
	}
#ifdef LITTLE_ENDIAN
	x0 = Rotl(x0, 16); x0 = ((x0 & 0x00FF00FF) << 8) ^ ((x0 & 0xFF00FF00) >> 8);
	x1 = Rotl(x1, 16); x1 = ((x1 & 0x00FF00FF) << 8) ^ ((x1 & 0xFF00FF00) >> 8);
	x2 = Rotl(x2, 16); x2 = ((x2 & 0x00FF00FF) << 8) ^ ((x2 & 0xFF00FF00) >> 8);
	x3 = Rotl(x3, 16); x3 = ((x3 & 0x00FF00FF) << 8) ^ ((x3 & 0xFF00FF00) >> 8);
#endif
	p = (muint32*)Output;
	p[0] = x3;
	p[1] = x2;
	p[2] = x1;
	p[3] = x0;

	return 1;
}
```
## CBC模式算法实现
CBC 模式主要基于两种思想，第一，所有分组的加密都链接在一起，其中各分组所用的密钥相同。加密时输入的是当前的明文分组和上一个密文分组的异或，这样使得密文分组不仅依赖当前明文
分组，而且还依赖前面所有的明文分组。因此，加密算法的输入不会显示出与这次的明文分组之间的固定关系，所以重复的明文分组不会再密文中暴露出这种重复关系。第二，加密过程使用初始量进行了随机化。基于在 1.2 中所实现的 SM4 加解密算法，便可很容易的实现 CBC 模式加密，具体核心代码如下所示：
```c

```
