## 项目目标
Research report on MPT，由于本次项目目的以学习为主，因此在编写本次report时大多以博客原话的形式进行呈现。为了日后方便查阅，笔者希望以一种笔记的方式进行展示，望读者见谅。引用博客将会在文末呈现，有兴趣的读者可自行查阅。
## 项目内容
### 前言
在以太坊的源码中，MPT树的源码主要在trie目录下，先初步分析一下三种树，Trie树、Patricia Trie树、Merkle树。有一个整体的直观印象。
#### Trie树
Trie树也叫作Radix树，为了提高效率，以太坊在实现上对其做了一些改进。在一般的radix树中，key是从树根到对应value得真实的路径。即从根节点开始，key中的每个字符会标识走那个子节点从而到达相应value。Value被存储在叶子节点，是每条路径的终止。假如key来自一个包含N个字符的字母表，那么树中的每个节点都可能会有多达N个孩子，树的最大深度是key的最大长度。
![图片](https://user-images.githubusercontent.com/105708747/181766658-4c76c3c3-54e0-4c77-9355-22695889744e.png)  
　Radix的好处是具有相同前缀的key所对应的value在树中是非常靠近的，并且trie中不会有像hash-table一样的冲突。但是它也有缺陷，假如有一个很长的key，没有其他的key和它有公共的前缀，那么在遍历或存储它对应的值得时候，你就会遍历或存储相当多的节点，因为这棵树是非常不平衡的。  
![图片](https://user-images.githubusercontent.com/105708747/181766738-6bb6879c-1291-48f1-b074-68f37c79e884.png)  
#### Patricia Trie树
又名RadixTree 或紧凑前缀树 (compact prefix tree)，它对 Trie树的空间使用率进行了优化。在PatriciaTrie 树中，如果父节点和子节点是一一映射，那么父节点与子节点将会合并。从而减少 Trie树 中的深度，在存储和遍历树节点时，降低时间和空间的开销。
![图片](https://user-images.githubusercontent.com/105708747/181766892-7df44f05-8342-4e33-81fe-4a7033544728.png)  
#### Merkle树
也叫哈希树，在比特币中，用它来做轻钱包spv的验证，网上有好多的资料和生成的方法和示例。  
默克尔树可以认为是一个两两哈希递归成一个ROOT的二叉树。看下面的图形很好理解。在实际的使用中，如果生成父哈希时，不够偶数，就把最后一个复制一次，形成一个偶数对。使用默克尔树的优点在于可以大幅的降低数据的下载，特别是在数据量增长较快较大时，数据本身成倍数增长，但默克尔树的数据量则增长变化非常小。
![图片](https://user-images.githubusercontent.com/105708747/181767042-97ecabb4-b141-4636-a9d5-86026527a534.png)  
### Merkle Patricia Tree定义
Merkle Patricia Tree(简称MPT树，实际上是一种trie前缀树)是以太坊中的一种加密认证的数据结构，可以用来存储所有的(key，value)对。以太坊区块的头部包括一个区块头，一个交易的列表和一个uncle区块的列表。在区块头部包括了交易的hash树根，用来校验交易的列表。在p2p网络上传输的交易是一个简单的列表，它们被组装成一个叫做trie树的特殊数据结构，来计算根hash。值得注意的是，除了校验区块外，这个数据结构并不是必须的，一旦区块被验证正确，那么它在技术上是可以忽略的。但是，这意味着交易列表在本地以trie树的形式存储，发送给客户端的时候序列化成列表。客户端接收到交易列表后重新构建交易列表trie树来验证根hash。RLP(Recursive length prefix encoding,递归长度前缀编码)，用来对trie树种所有的条目进行编码。
### 结点类型
MPT引入了很多节点类型来提高效率。MPT树中的节点包括空节点、叶子节点、扩展节点和分支节点。  
```
1.空节点。简单的表示空，在代码中是一个空串。  

2.标准的叶子节点。表示为[key,value]的一个list，其中key是key的一种特殊十六进制编码，value是value的RLP编码。  

3.扩展节点。也是[key，value]的列表，但是这里的value是其他节点的hash，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。  

4.分支节点。因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符，如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。  
```
在 MPT 中，hashNode很难单独存在，基本上在nodeFlag中以nodeFlag.hash为fullNode 和 shortNode间接持有。而在实际应用的场景中，这二者一旦改变，hashNode就一定会被更新。其实Block 的成员变量 Root、TxHash、ReceiptHash都与此有关。  
这样，这四个变量形成了一个完整的MPT树。
### 编码规则
在MPT中对KEY有三种编码： 
```
1.比特编码。这个比较简单，使用原生的字节流即可，这是大部分API的编码格式。  

2.Hex编码。将 keybytes 中的一个字节，高 4bit 和低 4bit 分别放到两个字节中，最后在尾部加 1byte 标记当前属于 Hex 格式（即原来的一个字节变成了三个字节）。新产生的KEY字节中的有效位只有4bit，这样的数据被称为nibble。然后就可以将其存储进fullNode.Children[] 数组了。  

3.Compact编码。这种编码的格式 和Hex编码正好相反，它是反推Hex到keybytes的格式。同时要加入Compact这种格式的标记。编码方法如下：  
```
```
第一步先将 Hex 尾部标记 byte 去掉，然后把两个 nibble 的数据合并到一他宽限；  
第二步，增加 一个字节在数据头部并填充 Compact 格式标记位00100000；  
第三步，如果Hex字符串有效长度为奇数，就将 Hex 字符串的第一个 nibble 放置在标记位字节中的低 4bit,并增加奇数位标志 0011xxxx。  
```
节点存储到数据库时候的key使用的就是Compact编码格式，这样可以可以节省磁盘空间。
### MPT部分操作
#### Get
```
1.若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。

2.若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。

3.若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。

4.若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。
```
![图片](https://user-images.githubusercontent.com/105708747/181772629-26d74c55-74c3-4bdf-baab-67310d7e242a.png)
#### Insert
```
1.根据Get中描述的查找步骤，首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；

2.若该Node为分支节点：
（1）剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；
（2）剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；

3.若该节点为叶子／扩展节点：
（1）剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；
（2）剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；

4.若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；
```
![图片](https://user-images.githubusercontent.com/105708747/181773085-4e01cf01-b360-46df-8073-e4b4dabcd45a.png)
#### Delete
```
1.根据Get中描述的查找步骤，找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；

2.若Node为叶子／扩展节点：
（1）若剩余的搜索路径与node的Key完全一致，则将整个node删除；
（2）若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；
（3）若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；

3.若Node为分支节点：
（1） 删除孩子列表中相应下标标志的节点；
（2） 删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；

4.若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；
```
![图片](https://user-images.githubusercontent.com/105708747/181773358-51af874a-d707-4685-b8bb-9739f6c8dbd7.png)
### 默克尔证明安全性
```
（1）若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。

由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。
```
```
（2）为什么不直接向全节点请求该节点是否存在于区块链中？

由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的默克尔路径，与代验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。
```
## 参考博客
[1]https://blog.csdn.net/qq_33935254/article/details/55505472  
[2]https://blog.csdn.net/qq_40713201/article/details/124486307  
[3]https://blog.csdn.net/shangsongwww/article/details/90111899  
[4]https://blog.csdn.net/fpcc/article/details/82078828  
[5]https://blog.csdn.net/shangsongwww/article/details/90300598  
